{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fmodern\fcharset0 Courier-Bold;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue120;\red163\green0\blue79;
\red255\green255\blue255;\red107\green0\blue109;\red135\green135\blue135;\red73\green17\blue135;\red148\green108\blue71;
\red0\green0\blue255;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c54510;\cssrgb\c70588\c0\c38431;
\cssrgb\c100000\c100000\c100000;\cssrgb\c50196\c0\c50196;\cssrgb\c60000\c60000\c60000;\cssrgb\c36078\c14902\c60000;\cssrgb\c65098\c49804\c34902;
\cssrgb\c0\c0\c100000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww15300\viewh16500\viewkind0
\deftab720
\pard\pardeftab720\sl560\sa240\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
Challenge 18: Recreate the pow() function 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\b\fs32 \cf2 Difficulty: 
\f2\b0 Easy\uc0\u8232 Create a function that accepts positive two integers, and raises the first to the power of the 
\f1\fs24 \

\f2\fs32 second.\uc0\u8232 
\f1\b Tip: 
\f2\b0 If you name your function 
\f3\b \cf3 myPow() 
\f2\b0 \cf2 or 
\f3\b \cf3 challenge18()
\f2\b0 \cf2 , you\'92ll be able to use the 
\f1\fs24 \

\f2\fs32 built-in 
\f3\b \cf3 pow() 
\f2\b0 \cf2 for your tests. The built-in 
\f3\b \cf3 pow() 
\f2\b0 \cf2 uses doubles, so you\'92ll need to typecast. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Sample input and output 
\f1\b0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The inputs 4 and 3 should return 64, i.e. 4 multiplied by itself 3 times. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The inputs 2 and 8 should return 256, i.e. 2 multiplied by itself 8 times. \uc0\u8232 
\f0\b\fs37\fsmilli18667 Hints 
\f2\b0\fs32 \uc0\u8232 
\f1\b Hint #1: 
\f2\b0 You don\'92t need any hints to solve this one.\uc0\u8232 
\f1\b Hint #2: 
\f2\b0 Oh, alright: here\'92s a hint: you can either use a loop or, if you\'92re feeling fancy, use a \uc0\u8232 recursive function. \u8232 
\f1\b Hint #3: 
\f2\b0 Here\'92s another: you could use 
\f3\b \cf3 guard 
\f2\b0 \cf2 or 
\f3\b \cf3 precondition() 
\f2\b0 \cf2 to ensure both numbers are positive.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
 \uc0\u8232 
\f0\b\fs37\fsmilli18667 Solution 
\f2\b0\fs32 \uc0\u8232 This ought to have been the easiest of easy challenges, because all you\'92re doing is multiplying a number against itself a fixed number of times. \u8232 In its most simple form, you can solve the challenge like this: \u8232 \
\pard\pardeftab720\sl360\partightenfactor0

\f4 \cf4 \cb5 func \cf6 challenge18a\cf7 (\cf2 number\cf7 : \cf8 Int\cf7 , \cf2 power\cf7 : \cf8 Int\cf7 ) \cf9 -> \cf8 Int \cf7 \{\
\cf4    guard \cf2 number \cf9 > \cf10 0\cf7 , \cf2 power \cf9 > \cf10 0 \cf4 else \cf7 \{ \cf4 return \cf10 0 \cf7 \}\
\cf4    var \cf2 returnValue \cf9 = \cf2 number\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f0 \cf2 \cb1 www.hackingwithswift.com 60 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 for \cf10 _ \cf4 in \cf10 1\cf7 ..\cf9 <\cf2 power \cf7 \{\
\cf2       returnValue \cf9 *= \cf2 number\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5    return \cf2 returnValue\
\cf7 \}\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 \cb1 Like I said in the hints, you could also solve this challenge using a recursive function. To do that, make the function multiply its input number by the return value of calling itself, subtracting 1 from the power parameter each time, like this: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 func \cf6 challenge18b\cf7 (\cf2 number\cf7 : \cf8 Int\cf7 , \cf2 power\cf7 : \cf8 Int\cf7 ) \cf9 -> \cf8 Int \cf7 \{\
\cf4    guard \cf2 number \cf9 > \cf10 0\cf7 , \cf2 power \cf9 > \cf10 0 \cf4 else \cf7 \{ \cf4 return \cf10 0 \cf7 \}\
\cf4    if \cf2 power \cf9 == \cf10 1 \cf7 \{ \cf4 return \cf2 number \cf7 \}\
\cf4    return \cf2 number \cf9 * \cf6 challenge18b\cf7 (\cf2 number\cf7 : \cf2 number\cf7 , \cf2 power\cf7 : \cf2 power \cf9 -\
\cf10 1\cf7 )\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} 
\f1\fs24 \cf2 \cb1 \
}